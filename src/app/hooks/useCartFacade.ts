import { useCallback, useMemo, useState, useEffect, useRef } from "react";
import { useCart } from "./useCart";
import { useAuth } from "./useAuth";
// guest cart support removed — cart now requires authenticated user
import { notify } from "@app/lib/toast";
import { useVinyl } from "./useVinyl";

// generated by IA

export function useCartFacade() {
  const { cart, getCart, addItemToCart, removeItemFromCart, updateCart, deleteCart, createUserCart, loading } = useCart();
  const { getVinylbyId } = useVinyl();
  // simple in-memory cache for vinyl details during component lifecycle
  const vinylCache = useRef<Record<string, any>>({});
  const { user } = useAuth();
  const enrichingRef = useRef(false);
  // Cart items are initialized from server cart only. Guest/local-storage cart removed.
  const [items, setItems] = useState(() => {
    try {
      if (cart && cart.length) {
        return cart.map((c: any) => ({ id: c.id, vinylId: c.vinylId ?? c.id, qty: c.qt ?? 1, name: c.name, price: c.price, coverPath: c.coverPath }));
      }
    } catch (e) {
      // ignore
    }
    return [];
  });

  // ...enrichment effect moved below after enrichItemsWithDetails declaration...

  // sync helper to map server cart to items
  const normalizeServerCart = useCallback((server: any): any[] => {
    if (!server) return [];
    if (Array.isArray(server)) return server;

    // If server is an envelope like { status: 'success', data: {...} }
    const maybeData = server.data ?? server.payload ?? server.body ?? null;
    if (Array.isArray(maybeData)) return maybeData;

    if (maybeData && typeof maybeData === "object") {
      // common keys
      if (Array.isArray(maybeData.cart)) return maybeData.cart;
      if (Array.isArray(maybeData.items)) return maybeData.items;
      if (Array.isArray(maybeData.vinyls)) return maybeData.vinyls;
      if (Array.isArray(maybeData.data)) return maybeData.data;
      // look for any first array value inside data
      try {
        const arr = Object.values(maybeData).find((v) => Array.isArray(v));
        if (Array.isArray(arr)) return arr as any[];
      } catch (e) {
        // ignore
      }
      // If data is an object mapping vinylId -> qty (e.g. { id1: 1, id2: 2 }), convert to array
      try {
        const entries = Object.entries(maybeData);
        const allNumericValues = entries.length > 0 && entries.every(([k, v]) => typeof v === 'number');
        if (allNumericValues) {
          return entries.map(([k, v]) => ({ id: k, vinylId: k, qt: v }));
        }
        // If values are objects with quantity fields, normalize too
        const entriesWithObjQty = entries.filter(([k, v]) => {
          const vv: any = v;
          return v && typeof v === 'object' && (vv.qt || vv.qty || vv.quantity);
        });
        if (entriesWithObjQty.length) {
          return entriesWithObjQty.map(([k, v]: any) => ({ id: k, vinylId: k, qt: (v as any).qt ?? (v as any).qty ?? (v as any).quantity }));
        }
      } catch (e) {
        // ignore
      }
    }

    // fallback: try top-level object values
    try {
      const guessed = Object.values(server).filter((v) => Array.isArray(v));
      if (guessed.length && Array.isArray(guessed[0])) return guessed[0];
    } catch (e) {
      // ignore
    }

    return [];
  }, []);

  const mapServerToItems = useCallback((serverCart: any) => {
    const arr = normalizeServerCart(serverCart);
    return arr.map((c: any) => ({ id: c.id, vinylId: c.vinylId ?? c.id, qty: c.qt ?? c.quantity ?? 1, name: c.name, price: c.price, coverPath: c.coverPath }));
  }, [normalizeServerCart]);

  const enrichItemsWithDetails = useCallback(async (itemsArr: any[]) => {
    const results = await Promise.all(itemsArr.map(async (it) => {
      const vid = it.vinylId ?? it.id;
      if (vinylCache.current[vid]) {
        const cached = vinylCache.current[vid] as any;
        const derivedName = cached.title ?? cached.name ?? (cached.artist ? `${cached.artist} - ${cached.title ?? ''}` : undefined);
        // derive coverPath (first element if array)
        const rawCover = Array.isArray(cached.coverPath) ? cached.coverPath[0] : cached.coverPath;
        const coverPath = rawCover ?? it.coverPath ?? '/images/placeholder.png';
        return { ...it, name: derivedName, price: cached.price ?? it.price, coverPath };
      }
      try {
        const vinyl = await getVinylbyId(vid);
  const detail = vinyl ?? {};
  vinylCache.current[vid] = detail;
  const derivedName = detail.title ?? detail.name ?? (detail.artist ? `${detail.artist} - ${detail.title ?? ''}` : undefined);
  const rawCover = Array.isArray(detail.coverPath) ? detail.coverPath[0] : detail.coverPath;
  const coverPath = rawCover ?? it.coverPath ?? '/images/placeholder.png';
  return { ...it, name: derivedName, price: detail.price ?? it.price, coverPath };
      } catch (e) {
        // on failure, return item without enrichment
        return it;
      }
    }));
    return results;
  }, [getVinylbyId]);

  // If any items lack name/price, enrich them (covers guest flows and initial state)
  useEffect(() => {
    let mounted = true;
    const needEnrich = (items || []).some((it: any) => !it.name || it.price === undefined);
    if (!needEnrich) return;
    if (enrichingRef.current) return;
    enrichingRef.current = true;
    (async () => {
      try {
        const enriched = await enrichItemsWithDetails(items || []);
        if (!mounted) return;
        // merge by vinylId
        const merged = (items || []).map((it: any) => {
          const vid = it.vinylId ?? it.id;
          const found = enriched.find((e: any) => (e.vinylId ?? e.id) === vid);
          return found ? { ...it, ...found } : it;
        });
        setItems(merged);
      } finally {
        enrichingRef.current = false;
      }
    })();
    return () => {
      mounted = false;
    };
  }, [items, enrichItemsWithDetails]);

  const refreshFromServer = useCallback(async (userId: string) => {
    const s = await getCart(userId);
    // debug: log raw server cart shape to help diagnose mapping issues
    try {
      // eslint-disable-next-line no-console
      console.debug("useCartFacade.refreshFromServer - raw server cart:", s);
    } catch (e) {}
    const mapped = mapServerToItems(s);
    // try to enrich with product details (name, price)
    const enriched = await enrichItemsWithDetails(mapped);
    try {
      // eslint-disable-next-line no-console
      console.debug("useCartFacade.refreshFromServer - mapped items:", mapped);
    } catch (e) {}
    setItems(enriched);
  }, [getCart, mapServerToItems]);

  // When user becomes available, refresh server cart so UI reflects authenticated cart
  useEffect(() => {
    if (user && (user as any).id) {
      // fire-and-forget
      refreshFromServer((user as any).id).catch((err) => {
        // eslint-disable-next-line no-console
        console.warn("Failed to refresh cart after login:", err);
      });
    }
  }, [user, refreshFromServer]);

  const add = useCallback(async (vinylId: string, qty = 1) => {
    if (!user || !user.id) throw new Error("You must be logged in to add items to the cart");
    try {
      await addItemToCart(user.id, vinylId, qty);
      await refreshFromServer(user.id);
      notify.success("Item added to cart");
    } catch (e) {
      notify.error("Failed to add item to cart");
      throw e;
    }
  }, [user, addItemToCart, refreshFromServer]);

  const remove = useCallback(async (vinylId: string) => {
    if (!user || !user.id) throw new Error("You must be logged in to remove items from the cart");
    try {
      await removeItemFromCart(user.id, vinylId);
      await refreshFromServer(user.id);
      notify.info("Item removed");
    } catch (e) {
      notify.error("Failed to remove item");
      throw e;
    }
  }, [user, removeItemFromCart, refreshFromServer]);

  const update = useCallback(async (vinylId: string, qty: number) => {
    if (!user || !user.id) throw new Error("You must be logged in to update the cart");
    try {
      await updateCart(user.id, [{ id: vinylId, vinylId, qt: qty } as any]);
      await refreshFromServer(user.id);
      notify.success("Cart updated");
    } catch (e) {
      notify.error("Failed to update cart");
      throw e;
    }
  }, [user, updateCart, refreshFromServer]);

  const clear = useCallback(async () => {
    if (!user || !user.id) throw new Error("You must be logged in to clear the cart");
    try {
      await deleteCart(user.id);
      setItems([]);
      notify.info("Cart cleared");
    } catch (e) {
      notify.error("Failed to clear cart");
      throw e;
    }
  }, [user, deleteCart]);

  // Guest cart merging removed — no guest/local cart support

  return useMemo(() => ({
    items,
    loading,
    add,
    remove,
    update,
    clear,
    refreshFromServer,
  }), [items, loading, add, remove, update, clear, refreshFromServer]);
}
